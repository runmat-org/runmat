{
  "title": "chol",
  "category": "math/linalg/factor",
  "keywords": [
    "chol",
    "cholesky",
    "factorization",
    "positive definite",
    "lower",
    "upper"
  ],
  "summary": "Cholesky factorization with MATLAB-compatible upper and lower forms.",
  "references": [],
  "gpu_support": {
    "elementwise": false,
    "reduction": false,
    "precisions": [
      "f64"
    ],
    "broadcasting": "none",
    "notes": "Uses provider chol hook when available, otherwise gathers to host and re-uploads the factor."
  },
  "fusion": {
    "elementwise": false,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::math::linalg::factor::chol::tests",
    "integration": "builtins::math::linalg::factor::chol::tests::chol_gpu_provider_roundtrip"
  },
  "description": "`chol(A)` computes a Cholesky factorization of a Hermitian positive-definite matrix `A`. By default, it returns the upper-triangular factor `R` satisfying `R' * R = A`. The two-output form `[R, p] = chol(A)` reports whether the factorization succeeded: `p = 0` for success, and otherwise `p` equals the index of the first leading principal minor that is not positive definite.",
  "behaviors": [
    "Single output (`chol(A)`): Returns the upper-triangular factor. If `A` is not positive definite, a MATLAB-compatible error (`\"Matrix must be positive definite.\"`) is raised.",
    "Two outputs (`[R, p] = chol(A)`): Returns the factor `R` and a flag `p`. When `p > 0`, `R` contains the partial factorization up to the `(p-1)`-th column.",
    "Lower form (`chol(A, 'lower')`): Returns a lower-triangular factor `L` such that `L * L' = A`. The two-output variant `[L, p] = chol(A, 'lower')` follows the same failure semantics.",
    "The option `'upper'` is accepted for completeness and matches the default behaviour.",
    "Real logical inputs are promoted to double precision. Complex inputs must be Hermitian positive definite (HPD); the factor preserves complex values.",
    "Scalar and `0\u00d70` inputs are supported. `chol([])` returns an empty matrix with `p = 0`."
  ],
  "examples": [
    {
      "description": "Upper-triangular Cholesky factor of a symmetric positive-definite matrix",
      "input": "A = [4 12 -16; 12 37 -43; -16 -43 98];\nR = chol(A)",
      "output": "R =\n     2     6    -8\n     0     1    -5\n     0     0     3"
    },
    {
      "description": "Lower-triangular factor using the `'lower'` option",
      "input": "A = [25 15 -5; 15 18  0; -5 0 11];\nL = chol(A, 'lower')",
      "output": "L =\n     5     0     0\n     3     3     0\n    -1     1     3"
    },
    {
      "description": "Detecting a non-positive-definite matrix with the two-output form",
      "input": "A = [1 2; 2 1];\n[R, p] = chol(A)",
      "output": "p =\n     2\n\nR =\n     1     2\n     0     0"
    },
    {
      "description": "Using the Cholesky factor to solve linear systems",
      "input": "A = [10 2 3; 2 9 1; 3 1 7];\nb = [1; 2; 3];\n[R, p] = chol(A);\nif p == 0\n    y = R' \\ b;\n    x = R \\ y;\nend"
    },
    {
      "description": "Cholesky factor of a complex Hermitian positive-definite matrix",
      "input": "A = [5 1-2i; 1+2i 4];\n[R, p] = chol(A)",
      "output": "p =\n     0\n\nR =\n    2.2361   0.2236 -0.8944i\n         0   1.9849 +0.5046i"
    },
    {
      "description": "Running `chol` on a `gpuArray`",
      "input": "G = gpuArray([6 2; 2 5]);\n[R, p] = chol(G);\nclass(R)",
      "output": "p =\n     0\n\nans =\n    'gpuArray'"
    }
  ],
  "faqs": [
    {
      "question": "What does the second output `p` mean?",
      "answer": "`p` is zero when the factorization succeeds. Otherwise, it is the index of the first leading principal minor that is not positive definite. The returned factor contains the partial result up to that point."
    },
    {
      "question": "How do I request the lower-triangular factor?",
      "answer": "Pass `'lower'` (case-insensitive) as the second argument: `[L, p] = chol(A, 'lower')`. The default behaviour (`chol(A)`) returns the upper-triangular factor."
    },
    {
      "question": "Why do I get an error when using a single output on an indefinite matrix?",
      "answer": "The single-output form matches MATLAB and throws an error when the matrix is not positive definite. Use the two-output form `[R, p]` to obtain the partial factor and inspect `p` without raising an error."
    },
    {
      "question": "Does `chol` accept sparse matrices?",
      "answer": "Not yet. RunMat currently implements the dense MATLAB semantics. Sparse support is planned in a future release."
    },
    {
      "question": "Can I pass logical or integer arrays?",
      "answer": "Yes. They are promoted to double precision before factorization, matching MATLAB behaviour."
    },
    {
      "question": "Do complex inputs need to be Hermitian?",
      "answer": "Yes. `chol` operates on Hermitian positive-definite matrices. If the matrix is not Hermitian, `p` will be non-zero in the two-output form, and the single-output form raises an error."
    },
    {
      "question": "How should I interpret the result when `p > 0`?",
      "answer": "Only the leading `(p-1)` columns/rows of the factor are valid. The remaining portions are zeros, mirroring MATLAB\u2019s contract."
    },
    {
      "question": "Does the GPU path return the same flag `p`?",
      "answer": "Yes. Providers report the MATLAB-compatible failure index, and RunMat converts it into the scalar second output."
    },
    {
      "question": "Is the factor unique?",
      "answer": "The standard Cholesky factorization returns an upper-triangular matrix with positive diagonal entries. The lower-triangular form is the conjugate transpose of the upper form and is likewise unique under the same assumptions."
    },
    {
      "question": "How should I choose between `chol` and `lu`/`qr`?",
      "answer": "Use `chol` when the matrix is Hermitian positive definite\u2014its triangular factors are cheaper to compute and exploit symmetry. Use `lu` or `qr` for more general matrices."
    }
  ],
  "links": [
    {
      "label": "lu",
      "url": "./lu"
    },
    {
      "label": "qr",
      "url": "./qr"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    },
    {
      "label": "gather",
      "url": "./gather"
    }
  ],
  "source": {
    "label": "`crates/runmat-runtime/src/builtins/math/linalg/factor/chol.rs`",
    "url": "https://github.com/runmat-org/runmat/blob/main/crates/runmat-runtime/src/builtins/math/linalg/factor/chol.rs"
  },
  "gpu_behavior": [
    "When RunMat Accelerate is active, the planner keeps `gpuArray` inputs on device and asks the registered provider for a `chol` factorization. Providers that implement the hook (the WGPU and in-process backends included) return the MATLAB-compatible flag `p` while leaving the triangular factor resident on the GPU. If the provider lacks that hook or the matrix uses an unsupported precision/type, RunMat gathers the data, executes the CPU implementation, and re-uploads the factor when a provider is present. The flag output is always materialised as a host scalar."
  ]
}
