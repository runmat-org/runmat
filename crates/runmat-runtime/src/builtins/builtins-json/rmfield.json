{
  "title": "rmfield",
  "category": "structs/core",
  "keywords": [
    "rmfield",
    "remove field",
    "struct",
    "struct array",
    "metadata"
  ],
  "summary": "Remove one or more fields from scalar structs or struct arrays.",
  "references": [],
  "gpu_support": {
    "elementwise": false,
    "reduction": false,
    "precisions": [],
    "broadcasting": "none",
    "notes": "Runs entirely on the host; values that already live on the GPU remain device-resident."
  },
  "fusion": {
    "elementwise": false,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::structs::core::rmfield::tests",
    "integration": "builtins::structs::core::rmfield::tests::rmfield_struct_array_roundtrip"
  },
  "description": "`S2 = rmfield(S, name)` returns a copy of `S` with the field `name` removed. The builtin accepts additional field names, string arrays, or cell arrays of names to delete several fields in one call.",
  "behaviors": [
    "Works with scalar structs and struct arrays created by `struct`, `load`, or other builtins.",
    "Accepts character vectors, string scalars, string arrays, and cell arrays containing those types to identify the fields that should be removed.",
    "Every listed field must already exist. Attempting to remove a missing field raises the standard MATLAB-style error `Reference to non-existent field '<name>'`.",
    "Removing multiple fields applies to every element in a struct array; the operation fails if any element is missing one of the requested fields.",
    "The input `S` is not mutated in place. `rmfield` returns a new struct (or struct array) while the original remains unchanged."
  ],
  "examples": [
    {
      "description": "Removing a single field from a scalar struct",
      "input": "s = struct(\"name\", \"Ada\", \"score\", 42);\nt = rmfield(s, \"score\");\nisfield(t, \"score\")",
      "output": "ans =\n  logical\n   0"
    },
    {
      "description": "Removing several fields with a cell array of names",
      "input": "cfg = struct(\"mode\", \"fast\", \"rate\", 60, \"debug\", true);\ncfg = rmfield(cfg, {\"rate\", \"debug\"});\nfieldnames(cfg)",
      "output": "ans =\n  1×1 cell array\n    {'mode'}"
    },
    {
      "description": "Removing a field from every element of a struct array",
      "input": "people = struct(\"name\", {\"Ada\", \"Grace\"}, \"id\", {101, 102}, \"email\", {\"ada@example.com\", \"grace@example.com\"});\ntrimmed = rmfield(people, \"email\");\nfieldnames(trimmed)",
      "output": "ans =\n  2×1 cell array\n    {'id'}\n    {'name'}"
    },
    {
      "description": "Supplying a string array of field names to delete",
      "input": "stats = struct(\"mean\", 10, \"median\", 9, \"stdev\", 2);\nnames = [\"mean\", \"median\"];\nreduced = rmfield(stats, names);\nfieldnames(reduced)",
      "output": "ans =\n  1×1 cell array\n    {'stdev'}"
    },
    {
      "description": "Conditionally removing optional fields",
      "input": "record = struct(\"id\", 7, \"notes\", \"draft\");\nif isfield(record, \"notes\")\n    record = rmfield(record, \"notes\");\nend\nfieldnames(record)",
      "output": "ans =\n  1×1 cell array\n    {'id'}"
    }
  ],
  "faqs": [
    {
      "question": "Does `rmfield` modify the input in place?",
      "answer": "No. The function returns a new struct (or struct array) with the specified fields removed. The input value remains unchanged, mirroring MATLAB's copy-on-write semantics."
    },
    {
      "question": "What argument types can I use for the field names?",
      "answer": "You can pass character vectors, string scalars, string arrays, or cell arrays whose elements are strings or character vectors. Mixing these forms in a single call is supported—`rmfield` concatenates all supplied names into one list."
    },
    {
      "question": "What happens if a field is missing?",
      "answer": "RunMat raises the MATLAB-compatible error `Reference to non-existent field '<name>'.` and leaves the struct unchanged."
    },
    {
      "question": "Can I remove nested fields with `rmfield`?",
      "answer": "No. `rmfield` only removes top-level fields. Use `setfield` with nested assignments or restructure your data if you need to manipulate nested content."
    },
    {
      "question": "Does `rmfield` work with MATLAB-style objects or handle classes?",
      "answer": "No. The builtin is restricted to structs and struct arrays. Use class-specific helpers (such as `rmprop`) for objects."
    },
    {
      "question": "Does removing a field move GPU tensors back to the CPU?",
      "answer": "No. The builtin merely rewrites metadata. Any GPU-resident values stored in remaining fields stay on the device until another operation decides otherwise."
    }
  ],
  "links": [
    {
      "label": "fieldnames",
      "url": "./fieldnames"
    },
    {
      "label": "isfield",
      "url": "./isfield"
    },
    {
      "label": "setfield",
      "url": "./setfield"
    },
    {
      "label": "struct",
      "url": "./struct"
    },
    {
      "label": "orderfields",
      "url": "./orderfields"
    }
  ],
  "source": {
    "label": "`crates/runmat-runtime/src/builtins/structs/core/rmfield.rs`",
    "url": "https://github.com/runmat-org/runmat/blob/main/crates/runmat-runtime/src/builtins/structs/core/rmfield.rs"
  },
  "gpu_residency": "No additional residency management is required. `rmfield` leaves existing GPU tensors untouched and never gathers or uploads buffers. Subsequent GPU-aware builtins decide whether to keep values on the device.",
  "gpu_behavior": [
    "`rmfield` performs metadata updates on the host. Values that already reside on the GPU—such as `gpuArray` tensors stored in other fields—stay on the device. Because this builtin only rewrites struct metadata it does not require or invoke acceleration provider hooks."
  ]
}
