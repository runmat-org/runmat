{
  "title": "polyder",
  "category": "math/poly",
  "keywords": [
    "polyder",
    "polynomial derivative",
    "product rule",
    "quotient rule",
    "gpu"
  ],
  "summary": "Differentiate polynomials, products, and ratios with MATLAB-compatible coefficient vectors.",
  "references": [
    "title: \"MATLAB polyder documentation\""
  ],
  "gpu_support": {
    "elementwise": false,
    "reduction": false,
    "precisions": [
      "f32",
      "f64"
    ],
    "broadcasting": "none",
    "notes": "When the active provider implements the polyder hooks, differentiation runs entirely on the GPU; otherwise coefficients are gathered back to the host. Complex coefficients continue to fall back to the CPU."
  },
  "fusion": {
    "elementwise": false,
    "reduction": false,
    "max_inputs": 2,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::math::poly::polyder::tests",
    "integration": "builtins::math::poly::polyder::tests::{gpu_inputs_remain_on_device,gpu_product_matches_cpu,gpu_quotient_matches_cpu,wgpu_polyder_single_matches_cpu,wgpu_polyder_product_matches_cpu,wgpu_polyder_quotient_matches_cpu}",
    "vm": "ignition::vm polyder multi-output dispatch"
  },
  "description": "`polyder` differentiates polynomials represented by their coefficient vectors. The coefficients follow MATLAB\u2019s convention: the first element corresponds to the highest power of `x`. The builtin supports three related operations:\n\n1. `polyder(p)` returns the derivative of a polynomial `p`. 2. `polyder(p, a)` applies the product rule to the convolution `conv(p, a)`. 3. `[num, den] = polyder(u, v)` returns the derivative of a rational function `u(x) / v(x)` using the quotient rule, yielding the numerator `num` and denominator `den`.",
  "behaviors": [
    "Accepts real or complex scalars, row vectors, column vectors, or empty vectors. Inputs with more than one non-singleton dimension raise MATLAB-compatible errors.",
    "Logical and integer coefficients are promoted to double precision before differentiation.",
    "Leading zeros are removed in outputs (unless the polynomial is identically zero, in which case a single zero coefficient is returned).",
    "The orientation of the first input polynomial is preserved for the derivative of a single polynomial or a product; the denominator in the quotient rule preserves the orientation of `v`.",
    "Calling `polyder(p, a)` with a single output applies the product rule. Capturing two outputs alongside two input polynomials returns the quotient-rule numerator and denominator (`u' * v - u * v'`, `v * v`).",
    "Empty inputs are treated as the zero polynomial.",
    "When inputs live on the GPU (e.g., `gpuArray`) and the active provider exposes the polyder hooks, differentiation runs entirely on-device and returns trimmed GPU tensors. Providers that lack the hooks fall back to gathering coefficients to the host, executing the reference CPU implementation, and returning host-resident results. Explicit calls to `gpuArray` remain available if you need to force residency."
  ],
  "examples": [
    {
      "description": "Differentiating a cubic polynomial",
      "input": "p = [3 -2 5 7];   % 3x^3 - 2x^2 + 5x + 7\ndp = polyder(p)",
      "output": "dp = [9 -4 5];"
    },
    {
      "description": "Applying the product rule",
      "input": "p = [1 0 -2];    % x^2 - 2\na = [1 1];       % x + 1\ndp = polyder(p, a);   % derivative of conv(p, a)",
      "output": "dp = [3 2 -2];"
    },
    {
      "description": "Differentiating a rational function",
      "input": "u = [1 0 -4];      % x^2 - 4\nv = [1 -1];        % x - 1\n[num, den] = polyder(u, v);    % derivative of (u / v)",
      "output": "num = [1 -2 4];\nden = [1 -2 1];"
    },
    {
      "description": "Preserving column-vector orientation",
      "input": "p = [1; 0; -3];    % column vector coefficients\ndp = polyder(p)",
      "output": "dp =\n     2\n     0"
    },
    {
      "description": "Differentiating complex-valued coefficients",
      "input": "p = [1+2i, -3, 4i];\ndp = polyder(p)",
      "output": "dp = [2+4i, -3];"
    },
    {
      "description": "Working with gpuArray inputs",
      "input": "g = gpuArray([2 0 -5 4]);\ndp = polyder(g);         % stays on the GPU when provider hooks are available\nresult = gather(dp)",
      "output": "result = [6 0 -5];"
    }
  ],
  "faqs": [
    {
      "question": "What happens if I pass an empty coefficient vector?",
      "answer": "The empty vector represents the zero polynomial. `polyder([])` returns `[0]`, and the product and quotient forms treat empty inputs as zeros."
    },
    {
      "question": "Does `polyder` support column-vector coefficients?",
      "answer": "Yes. The orientation of the first polynomial is preserved for single-polynomial and product derivatives. For the quotient rule, the numerator inherits the orientation of `u` and the denominator inherits the orientation of `v`."
    },
    {
      "question": "How are leading zeros handled in the result?",
      "answer": "Leading zeros are removed automatically to mirror MATLAB. If all coefficients cancel out, a single zero coefficient is returned."
    },
    {
      "question": "Can I differentiate logical or integer coefficient vectors?",
      "answer": "Yes. Logical and integer inputs are promoted to double precision before differentiation, matching MATLAB semantics."
    },
    {
      "question": "How do I compute the derivative of a rational function?",
      "answer": "Call `[num, den] = polyder(u, v)`. The numerator and denominator are the coefficients of `(u' * v - u * v')` and `v * v`, respectively, with leading zeros removed."
    },
    {
      "question": "Does the builtin launch GPU kernels?",
      "answer": "Yes whenever the active acceleration provider implements the `polyder` hooks. The in-process and WGPU backends both execute the derivative on the device. Providers that lack the hooks\u2014or inputs that require complex arithmetic\u2014fall back to the CPU reference implementation, returning the result on the host. Wrap the output in `gpuArray` manually if you need to restore device residency in that case."
    },
    {
      "question": "What if I request more than two outputs?",
      "answer": "`polyder` only defines one or two outputs. Additional requested outputs are filled with `0`, just as RunMat currently does for other MATLAB builtins whose extra outputs are ignored."
    },
    {
      "question": "Are complex coefficients supported in the quotient rule?",
      "answer": "Yes. Both the numerator and denominator are computed using full complex arithmetic, so mixed real/complex inputs work without additional steps."
    },
    {
      "question": "Do I need to normalise or pad my coefficient vectors?",
      "answer": "No. Provide coefficients exactly as MATLAB expects (highest power first). The builtin takes care of padding, trimming, and orientation."
    },
    {
      "question": "How precise is the computation?",
      "answer": "All arithmetic uses IEEE 754 double precision (`f64`), matching MATLAB\u2019s default numeric type."
    }
  ],
  "links": [
    {
      "label": "polyval",
      "url": "./polyval"
    },
    {
      "label": "polyfit",
      "url": "./polyfit"
    },
    {
      "label": "conv",
      "url": "./conv"
    },
    {
      "label": "deconv",
      "url": "./deconv"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    },
    {
      "label": "gather",
      "url": "./gather"
    }
  ],
  "source": {
    "label": "`crates/runmat-runtime/src/builtins/math/poly/polyder.rs`",
    "url": "https://github.com/runmat-org/runmat/blob/main/crates/runmat-runtime/src/builtins/math/poly/polyder.rs"
  },
  "gpu_behavior": [
    "When a provider advertises the `polyder` hooks (the in-process and WGPU backends both do), single polynomials and the product/quotient forms execute fully on the GPU. Outputs preserve the orientation of the leading input while trimming leading zeros exactly as the CPU path does. If the provider declines the request\u2014because the coefficients are complex or the backend lacks support\u2014 RunMat automatically gathers the inputs and falls back to the CPU reference implementation to preserve MATLAB compatibility."
  ]
}
