{
  "title": "isinf",
  "category": "logical/tests",
  "keywords": [
    "isinf",
    "infinite mask",
    "numeric predicate",
    "gpuArray isinf",
    "MATLAB isinf"
  ],
  "summary": "Return a logical mask indicating which elements of the input are ±Inf.",
  "references": [],
  "gpu_support": {
    "elementwise": true,
    "reduction": false,
    "precisions": [
      "f32",
      "f64"
    ],
    "broadcasting": "matlab",
    "notes": "Runs on the GPU when the provider exposes `logical_isinf`; otherwise the runtime gathers to the host transparently."
  },
  "fusion": {
    "elementwise": true,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::logical::tests::isinf::tests",
    "integration": "builtins::logical::tests::isinf::tests::isinf_gpu_roundtrip",
    "gpu": "builtins::logical::tests::isinf::tests::isinf_wgpu_matches_host_path"
  },
  "description": "`mask = isinf(x)` returns a logical scalar or array indicating which elements of `x` are positive or negative infinity. The output matches MATLAB's semantics for scalars, matrices, higher-dimensional tensors, strings, logical arrays, and gpuArray values.",
  "behaviors": [
    "Numeric scalars return a logical scalar (`true`/`false`).",
    "Numeric arrays return a logical array of the same size, with `true` wherever the corresponding element is `+Inf` or `-Inf`.",
    "Complex inputs report `true` when either the real or the imaginary component is infinite.",
    "Logical inputs return `false` because logical values (0 or 1) are finite by construction.",
    "Character arrays return logical arrays of zeros (characters map to finite code points).",
    "String arrays return logical arrays of zeros, mirroring MATLAB behavior.",
    "`string` scalars (string objects) return a logical scalar `false`.",
    "When the input is a `gpuArray`, RunMat keeps the computation on the device if the active acceleration provider implements the `logical_isinf` hook; otherwise the runtime gathers the data back to the host automatically."
  ],
  "examples": [
    {
      "description": "Checking if a scalar is infinite",
      "input": "result = isinf(1/0);",
      "output": "result =\n     1"
    },
    {
      "description": "Detecting infinities after division by zero",
      "input": "A = [1 0; 2 0];\nquot = 1 ./ A;\nmask = isinf(quot);",
      "output": "mask =\n  2×2 logical array\n     0     1\n     0     1"
    },
    {
      "description": "Flagging infinite components of a complex array",
      "input": "Z = [Inf+0i 1-Inf*1i 2+3i];\nmask = isinf(Z);",
      "output": "mask =\n  1×3 logical array\n     1     1     0"
    },
    {
      "description": "Applying `isinf` to character data",
      "input": "chars = ['R' 'u' 'n'];\nmask = isinf(chars);",
      "output": "mask =\n  1×3 logical array\n     0     0     0"
    },
    {
      "description": "Running `isinf` directly on the GPU",
      "input": "G = gpuArray([1 -Inf Inf]);\nmask_gpu = isinf(G);\nmask = gather(mask_gpu);",
      "output": "mask =\n  1×3 logical array\n     0     1     1"
    }
  ],
  "faqs": [
    {
      "question": "Does `isinf` treat `NaN` values as infinite?",
      "answer": "No. `isinf` only reports `true` for IEEE positive or negative infinity. `NaN` values return `false`, so you can combine `isinf` with `isnan` when you need to distinguish between the two."
    },
    {
      "question": "What does `isinf` return for logical inputs?",
      "answer": "Logical inputs always produce `false` because logical values are limited to 0 or 1, which are finite."
    },
    {
      "question": "How does `isinf` handle complex numbers?",
      "answer": "It returns `true` when either the real or the imaginary component is infinite, matching MATLAB semantics."
    },
    {
      "question": "Does `isinf` move data between the CPU and GPU?",
      "answer": "Only when necessary. If the selected provider implements `logical_isinf`, all work stays on the GPU. Otherwise, RunMat gathers the tensor to the host, computes the result, and delivers a logical array."
    },
    {
      "question": "What happens with string or character inputs?",
      "answer": "String scalars return `false`. Character arrays and string arrays return logical zeros with the same shape as the input."
    },
    {
      "question": "Is there a performance difference between `isinf`, `isnan`, and `isfinite`?",
      "answer": "Each predicate performs a single elementwise test. Performance is dominated by memory bandwidth, so they have comparable cost on both CPU and GPU."
    }
  ],
  "links": [
    {
      "label": "isfinite",
      "url": "./isfinite"
    },
    {
      "label": "isnan",
      "url": "./isnan"
    },
    {
      "label": "isreal",
      "url": "./isreal"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    },
    {
      "label": "gather",
      "url": "./gather"
    }
  ],
  "source": {
    "label": "`crates/runmat-runtime/src/builtins/logical/tests/isinf.rs`",
    "url": "https://github.com/runmat-org/runmat/blob/main/crates/runmat-runtime/src/builtins/logical/tests/isinf.rs"
  },
  "gpu_residency": "You usually do **not** need to call `gpuArray` explicitly. RunMat's auto-offload planner keeps tensors on the GPU across fused expressions when that improves performance. You can still seed residency manually with `gpuArray` for compatibility with MATLAB scripts or when you want fine-grained control over data movement.",
  "gpu_behavior": [
    "When RunMat Accelerate is active, `isinf` looks for the provider hook `logical_isinf`. Providers that implement the hook execute the infinity test entirely on the GPU, producing a logical gpuArray result without any host transfers. If the hook is absent, RunMat gathers the input tensor back to the CPU, computes the mask on the host, and returns a regular logical array so the builtin always succeeds."
  ]
}