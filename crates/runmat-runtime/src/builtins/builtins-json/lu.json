{
  "title": "lu",
  "category": "math/linalg/factor",
  "keywords": [
    "lu",
    "factorization",
    "decomposition",
    "lower-upper",
    "permutation"
  ],
  "summary": "LU decomposition with partial pivoting, matching MATLAB semantics.",
  "references": [],
  "gpu_support": {
    "elementwise": false,
    "reduction": false,
    "precisions": [
      "f64"
    ],
    "broadcasting": "none",
    "notes": "Uses the provider `lu` hook when available; otherwise gathers to the host fallback implementation."
  },
  "fusion": {
    "elementwise": false,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::math::linalg::factor::lu::tests",
    "integration": "builtins::math::linalg::factor::lu::tests::lu_three_outputs_matches_factorization"
  },
  "description": "`lu(A)` computes the LU factorization of a real or complex matrix `A` using partial pivoting. It exposes the same calling forms as MATLAB:\n\n- Single output: `lu(A)` returns a single matrix whose strictly lower-triangular entries encode `L` (with an implicit unit diagonal) and whose upper-triangular part encodes `U`. - Two outputs: `[L, U] = lu(A)` returns the explicit unit-lower-triangular factor `L` and the upper-triangular factor `U`. - Three outputs: `[L, U, P] = lu(A)` additionally returns a permutation so that `P * A = L * U`. Use the option `'vector'` to receive the permutation as a pivot vector instead of a matrix.\n\nThe implementation follows MATLAB’s dense behaviour for full matrices and supports rectangular inputs.",
  "behaviors": [
    "Partial pivoting is applied to improve numerical stability. The permutation is encoded either as a dense matrix (`'matrix'`, default) or as a pivot vector (`'vector'`).",
    "Rectangular inputs are supported. `L` is always `m × m` (unit lower-triangular), and `U` is `m × n`, where `m` and `n` are the row and column counts of `A`.",
    "Singular matrices are permitted. Zero pivots propagate into the `U` factor just as in MATLAB; MATLAB-compatible warnings are not yet emitted.",
    "Only the first three outputs are implemented today. Column permutations (`Q`) and scaling (`R`) for the five-output sparse form are not yet available."
  ],
  "examples": [
    {
      "description": "Factorizing a square matrix with `lu`",
      "input": "A = [2 1 1; 4 -6 0; -2 7 2];\n[L, U, P] = lu(A)",
      "output": "L =\n     1     0     0\n    -1     1     0\n     0    -1     1\n\nU =\n     4    -6     0\n     0     1     1\n     0     0     3\n\nP =\n     0     1     0\n     1     0     0\n     0     0     1"
    },
    {
      "description": "Obtaining only the combined LU factor",
      "input": "LU = lu([1 3 5; 2 4 7; 1 1 0])",
      "output": "LU =\n     2     4     7\n   0.5     1   -1.5\n   0.5   -0.5    2"
    },
    {
      "description": "Requesting the permutation vector with the `'vector'` option",
      "input": "[L, U, p] = lu([4 3; 6 3], 'vector')",
      "output": "p =\n     2\n     1"
    },
    {
      "description": "LU factorization of a rectangular matrix",
      "input": "A = [3 1 2; 6 3 4];\n[L, U, P] = lu(A)",
      "output": "L =\n     1     0\n     0.5   1\n\nU =\n     6     3     4\n     0    -0.5    0\n\nP =\n     0     1\n     1     0"
    },
    {
      "description": "Using LU factors to solve a linear system",
      "input": "A = [3 1 2; 6 3 4];\nb = [1; 2];\n[L, U, P] = lu(A);\ny = L \\ (P * b);\nx = U \\ y",
      "output": "x =\n    0.0\n    0.5\n   -0.0"
    },
    {
      "description": "Running `lu` on a `gpuArray`",
      "input": "G = gpuArray([10 7; 3 2]);\n[L, U, P] = lu(G);\nclass(L)\nclass(U)\nclass(P)",
      "output": "ans =\n    'gpuArray'\n\nans =\n    'gpuArray'\n\nans =\n    'gpuArray'"
    }
  ],
  "faqs": [
    {
      "question": "Why does RunMat currently stop at three outputs?",
      "answer": "Column pivoting (`Q`) and scaling (`R`) from MATLAB’s five-output sparse form are planned but not yet implemented. The dense three-output contract mirrors MATLAB’s default dense behaviour."
    },
    {
      "question": "Does the permutation vector use MATLAB’s 1-based indexing?",
      "answer": "Yes. When you request `'vector'`, the returned pivot vector contains 1-based row indices so that `A(p, :) = L * U`."
    },
    {
      "question": "How are singular matrices handled?",
      "answer": "Partial pivoting proceeds exactly as in MATLAB. If a pivot column is entirely zero, the corresponding diagonal entries in `U` become zero. No warning is emitted yet."
    },
    {
      "question": "Are complex matrices supported?",
      "answer": "Yes. Complex inputs produce complex `L`, `U`, and `LU`. The permutation remains real because it only contains zeros and ones."
    },
    {
      "question": "Will the factors stay on the GPU when I pass a `gpuArray`?",
      "answer": "Yes. When the active acceleration provider exposes the `lu` hook (WGPU today), the combined factor, `L`, `U`, and the permutation outputs remain `gpuArray` values—the provider currently performs the decomposition on the host once and reuploads the results to preserve residency. Without provider support, RunMat gathers to host memory before returning the factors."
    },
    {
      "question": "Can I call `lu` on logical arrays?",
      "answer": "Yes. Logical inputs are promoted to double precision before factorization, matching MATLAB semantics."
    },
    {
      "question": "Is pivoting deterministic?",
      "answer": "Yes. Partial pivoting always chooses the first maximal entry in each column, mirroring MATLAB’s behaviour for dense matrices."
    },
    {
      "question": "How accurate is the factorization?",
      "answer": "The implementation uses standard double-precision arithmetic (or complex double when needed). Numerical properties therefore match MATLAB’s dense fallback (without iterative refinement)."
    },
    {
      "question": "What happens if I pass more than one option argument?",
      "answer": "RunMat currently supports at most one option string (`'matrix'` or `'vector'`). Passing additional options raises an error."
    },
    {
      "question": "Can I reuse the combined LU factor to solve systems?",
      "answer": "Yes. The combined matrix returned by `lu(A)` stores `L` in the strictly lower-triangular part (with an implicit unit diagonal) and `U` in the upper-triangular part, just like MATLAB. You can use forward/back substitution routines that understand this layout."
    }
  ],
  "links": [
    {
      "label": "det",
      "url": "./det"
    },
    {
      "label": "inv",
      "url": "./inv"
    },
    {
      "label": "chol",
      "url": "./chol"
    },
    {
      "label": "qr",
      "url": "./qr"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    }
  ],
  "source": {
    "label": "crates/runmat-runtime/src/builtins/math/linalg/factor/lu.rs",
    "url": "crates/runmat-runtime/src/builtins/math/linalg/factor/lu.rs"
  },
  "gpu_behavior": [
    "When an acceleration provider implements the `lu` hook (the WGPU provider does), the factorization executes through that provider and the combined LU factor, `L`, `U`, and permutation outputs all remain on the device. The current WGPU backend performs the decomposition on the host once and immediately reuploads the factors so residency is preserved until dedicated kernels land.",
    "The `'vector'` option likewise returns a GPU-resident pivot vector when a provider hook is active.",
    "If no provider hook is available, RunMat automatically gathers the input to host memory and falls back to the CPU implementation so behaviour stays MATLAB-compatible."
  ]
}
