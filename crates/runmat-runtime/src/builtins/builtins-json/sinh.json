{
  "title": "sinh",
  "category": "math/trigonometry",
  "keywords": [
    "sinh",
    "hyperbolic",
    "trigonometry",
    "gpu"
  ],
  "summary": "Hyperbolic sine of scalars, vectors, matrices, or N-D tensors (element-wise).",
  "references": [],
  "gpu_support": {
    "elementwise": true,
    "reduction": false,
    "precisions": [
      "f32",
      "f64"
    ],
    "broadcasting": "matlab",
    "notes": "Prefers provider unary_sinh hooks; falls back to the host path when the active provider cannot service the request."
  },
  "fusion": {
    "elementwise": true,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::math::trigonometry::sinh::tests",
    "integration": "builtins::math::trigonometry::sinh::tests::sinh_gpu_provider_roundtrip"
  },
  "description": "`Y = sinh(X)` computes the hyperbolic sine of every element in `X`, treating angles as real numbers and extending naturally to complex values.",
  "behaviors": [
    "Works on scalars, vectors, matrices, and N-D tensors with MATLAB broadcasting semantics.",
    "Logical inputs are converted to double precision (`true \u2192 1.0`, `false \u2192 0.0`) before evaluation.",
    "Complex inputs follow the analytic definition `sinh(a + bi) = sinh(a)cos(b) + i\u00b7cosh(a)sin(b)`, propagating `NaN`/`Inf` components independently.",
    "Character arrays are converted to their numeric code points prior to evaluation, returning double arrays of the same size.",
    "Empty arrays return empty results that respect MATLAB\u2019s shape semantics."
  ],
  "examples": [
    {
      "description": "Compute the hyperbolic sine of a scalar value",
      "input": "y = sinh(1);",
      "output": "y = 1.1752;"
    },
    {
      "description": "Apply `sinh` to each element of a vector",
      "input": "x = linspace(-1, 1, 5);\ny = sinh(x);",
      "output": "y = [-1.1752 -0.5211 0 0.5211 1.1752];"
    },
    {
      "description": "Evaluate `sinh` on a matrix",
      "input": "A = [0 1; 2 3];\nB = sinh(A);",
      "output": "B = [0 1.1752; 3.6269 10.0179];"
    },
    {
      "description": "Compute the hyperbolic sine on the GPU",
      "input": "G = gpuArray([0.25 0.5; 0.75 1.0]);\nresult_gpu = sinh(G);\nresult = gather(result_gpu);",
      "output": "result = [0.2526 0.5211; 0.8223 1.1752];"
    },
    {
      "description": "Work with complex inputs",
      "input": "z = 1 + 2i;\nw = sinh(z);",
      "output": "w = -0.4891 + 1.4031i;"
    }
  ],
  "faqs": [
    {
      "question": "When should I use `sinh`?",
      "answer": "Use `sinh` for hyperbolic sine transformations, signal-processing workflows, and analytic continuations where the hyperbolic trigonometric family is required."
    },
    {
      "question": "Does `sinh` work with complex numbers?",
      "answer": "Yes. The real and imaginary parts are evaluated using the analytic definition `sinh(a + bi) = sinh(a)cos(b) + i\u00b7cosh(a)sin(b)`."
    },
    {
      "question": "What happens if the provider does not implement `unary_sinh`?",
      "answer": "RunMat gathers the GPU tensor to host memory, performs the computation on the CPU, and leaves the result on the host unless later operations require GPU residency."
    },
    {
      "question": "Can `sinh` participate in fusion?",
      "answer": "Yes. The fusion planner can inline `sinh` inside elementwise groups, generating WGSL kernels that execute directly on the GPU."
    },
    {
      "question": "Does `sinh` respect MATLAB broadcasting rules?",
      "answer": "It operates elementwise and therefore respects the same scalar-expansion (broadcasting) semantics as other MATLAB math functions in RunMat."
    },
    {
      "question": "Are integers preserved?",
      "answer": "Inputs are promoted to double precision before evaluation. To keep data in integer form, perform downstream casting explicitly."
    },
    {
      "question": "How does `sinh` handle NaN or Inf values?",
      "answer": "Hyperbolic functions propagate `NaN` and `Inf` components consistently with MATLAB. For complex inputs, each component is treated independently."
    },
    {
      "question": "Can I combine `sinh` with other hyperbolic functions?",
      "answer": "Yes. `sinh`, `cosh`, and `tanh` will share the same residency rules. Fused expressions can include any combination of elementwise builtins."
    },
    {
      "question": "Is there a GPU warmup penalty?",
      "answer": "Providers may warm up pipelines during initialization. If `unary_sinh` is unavailable, the CPU fallback ensures correctness without warmup."
    }
  ],
  "links": [
    {
      "label": "sin",
      "url": "./sin"
    },
    {
      "label": "cos",
      "url": "./cos"
    },
    {
      "label": "tan",
      "url": "./tan"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    },
    {
      "label": "gather",
      "url": "./gather"
    }
  ],
  "source": {
    "label": "`crates/runmat-runtime/src/builtins/math/trigonometry/sinh.rs`",
    "url": "https://github.com/runmat-org/runmat/blob/main/crates/runmat-runtime/src/builtins/math/trigonometry/sinh.rs"
  },
  "gpu_residency": "You usually do **not** need to call `gpuArray` explicitly. The fusion planner keeps tensors on the GPU whenever the active provider exposes the necessary kernels (such as `unary_sinh`). Manual `gpuArray` / `gather` calls remain supported for MATLAB compatibility or when you need to pin residency before interacting with external code.",
  "gpu_behavior": [
    "When RunMat Accelerate is active, tensors that already reside on the GPU stay there. Providers that implement `unary_sinh` execute the operation entirely on the device (and fused elementwise kernels can inline `sinh` as part of a larger expression). If the active provider lacks this hook, RunMat gathers the data back to the host, computes the result, and re-uploads only when later operations require GPU residency."
  ]
}
