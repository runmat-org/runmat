{
  "title": "any",
  "category": "math/reduction",
  "keywords": [
    "any",
    "logical reduction",
    "omitnan",
    "all",
    "gpu"
  ],
  "summary": "Test whether any element of an array is nonzero with MATLAB-compatible options.",
  "references": [],
  "gpu_support": {
    "elementwise": false,
    "reduction": true,
    "precisions": [
      "f32",
      "f64"
    ],
    "broadcasting": "matlab",
    "notes": "RunMat uses provider hooks (`reduce_any_dim`, `reduce_any`) when available; otherwise the runtime gathers to the host and evaluates there."
  },
  "fusion": {
    "elementwise": false,
    "reduction": true,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::math::reduction::any::tests",
    "integration": "builtins::math::reduction::any::tests::any_gpu_provider_roundtrip"
  },
  "description": "`any(X)` returns logical `true` wherever at least one element of the requested slice of `X` is nonzero. When you omit the dimension, the reduction runs along the first non-singleton axis, mirroring MATLAB.",
  "behaviors": [
    "Works with logical, numeric, complex, and character arrays; other types raise a descriptive error.",
    "Accepts `any(X, dim)` to reduce along a single dimension or `any(X, vecdim)` to collapse multiple axes at once.",
    "`any(X, 'all')` flattens the entire array into a single logical scalar.",
    "`any(___, 'omitnan')` ignores `NaN` values (including complex parts) when deciding whether a slice contains nonzero content.",
    "`any(___, 'includenan')` (default) treats `NaN` as logical `true`, matching MATLAB behaviour.",
    "Empty dimensions yield logical zeros with MATLAB-compatible shapes; empty arrays reduced with `'all'` return `false`.",
    "Results are always host-resident logical scalars or logical arrays, even when the input tensor lives on the GPU, because the runtime copies the compact output back to the CPU."
  ],
  "examples": [
    {
      "description": "Checking if any column in a matrix is nonzero",
      "input": "A = [0 2 0; 0 0 0];\ncolHasData = any(A)",
      "output": "colHasData = [0 1 0]"
    },
    {
      "description": "Detecting whether any row contains a nonzero entry",
      "input": "B = [0 4 0; 1 0 0; 0 0 0];\nrowHasData = any(B, 2)",
      "output": "rowHasData = [1; 1; 0]"
    },
    {
      "description": "Reducing across multiple dimensions with `vecdim`",
      "input": "C = reshape(1:24, [3 4 2]);\nhasValues = reshape(any(C > 20, [1 2]), 1, 2)",
      "output": "0 1"
    },
    {
      "description": "Checking all elements with the `'all'` option",
      "input": "D = [0 0; 0 5];\nanyNonZero = any(D, 'all')",
      "output": "anyNonZero = true"
    },
    {
      "description": "Ignoring `NaN` values when probing slices",
      "input": "E = [NaN 0 0; 0 0 0];\nwithNaN = any(E);              % returns [1 0 0]\nignoringNaN = any(E, 'omitnan'); % returns [0 0 0]\ndisp(withNaN);\ndisp(ignoringNaN)",
      "output": "     1     0     0\n     0     0     0"
    },
    {
      "description": "Running `any` on GPU arrays with automatic fallback",
      "input": "G = gpuArray([0 1 0; 0 0 0]);\ngpuResult = any(G, 2);\nhostResult = gather(gpuResult);\ndisp(hostResult)",
      "output": "1\n0"
    },
    {
      "description": "Evaluating `any` on character data",
      "input": "chars = ['a' 0 'c'];\nhasPrintable = any(chars)",
      "output": "hasPrintable = 1"
    }
  ],
  "faqs": [
    {
      "question": "When should I use the `any` function?",
      "answer": "Use `any` whenever you need to know if any element of an array, row, column, or sub-array is nonzero or logical `true`."
    },
    {
      "question": "Does `any` always return logical values?",
      "answer": "Yes. Results are `logical` scalars or logical arrays even when the computation involves GPU inputs."
    },
    {
      "question": "How do I test a specific dimension?",
      "answer": "Pass the dimension as the second argument (for example, `any(X, 2)` reduces each row). Provide a vector such as `[1 3]` to collapse multiple axes."
    },
    {
      "question": "What does `any(X, 'all')` compute?",
      "answer": "It reduces across every dimension of `X` and returns a single logical scalar indicating whether any element of the entire array is nonzero."
    },
    {
      "question": "How are `NaN` values handled?",
      "answer": "By default they count as nonzero (`'includenan'`). Add `'omitnan'` to ignore them; if every element in a slice is `NaN`, the result becomes `false`."
    },
    {
      "question": "Does `any` work with complex numbers?",
      "answer": "Yes. Complex values are considered nonzero when either the real or imaginary component is nonzero. Complex values containing `NaN` obey the `'omitnan'`/`'includenan'` rules."
    },
    {
      "question": "Can I apply `any` to character arrays?",
      "answer": "Yes. Characters compare against their Unicode code points; zero-valued code points are treated as `false`, and everything else is `true`."
    },
    {
      "question": "What happens with empty inputs?",
      "answer": "Empty reductions follow MATLAB semantics: dimensions of length zero produce logical zeros, while `any(X, 'all')` over an empty array evaluates to `false`."
    },
    {
      "question": "How do GPU backends accelerate `any`?",
      "answer": "Providers may expose specialised OR-reduction kernels (`reduce_any_dim`, `reduce_any`) or use `fused_reduction` to remain on the device. When such hooks are absent, RunMat downloads the small output and computes on the host."
    }
  ],
  "links": [
    {
      "label": "sum",
      "url": "./sum"
    },
    {
      "label": "prod",
      "url": "./prod"
    },
    {
      "label": "mean",
      "url": "./mean"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    },
    {
      "label": "gather",
      "url": "./gather"
    }
  ],
  "source": {
    "label": "`crates/runmat-runtime/src/builtins/math/reduction/any.rs`",
    "url": "https://github.com/runmat-org/runmat/blob/main/crates/runmat-runtime/src/builtins/math/reduction/any.rs"
  },
  "gpu_residency": "You usually do **not** need to call `gpuArray` manually. The fusion planner keeps GPU-resident inputs on the device and only gathers the small logical results that `any` produces. If your workload already uses explicit `gpuArray`/`gather` calls for MATLAB compatibility, RunMat honours them and still produces correct logical outputs.",
  "gpu_behavior": [
    "RunMat Accelerate keeps inputs resident on the GPU whenever possible. Providers that expose `reduce_any_dim` (and optionally `reduce_any`) perform the OR-reduction on device buffers, and the runtime then downloads the tiny logical result back to the CPU (every `any` call returns a host logical array). When those hooks are missing, RunMat gathers the input tensor and evaluates the reduction on the host instead, preserving MATLAB behaviour in all cases."
  ]
}
