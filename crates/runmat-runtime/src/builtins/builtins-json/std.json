{
  "title": "std",
  "category": "math/reduction",
  "keywords": [
    "std",
    "standard deviation",
    "statistics",
    "gpu",
    "omitnan",
    "all",
    "like",
    "native"
  ],
  "summary": "Standard deviation of scalars, vectors, matrices, or N-D tensors with MATLAB-compatible options.",
  "references": [],
  "gpu_support": {
    "elementwise": false,
    "reduction": true,
    "precisions": [
      "f32",
      "f64"
    ],
    "broadcasting": "matlab",
    "notes": "Falls back to host when 'omitnan' is requested or the provider lacks std reductions."
  },
  "fusion": {
    "elementwise": false,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::math::reduction::std::tests",
    "integration": "builtins::math::reduction::std::tests::std_gpu_provider_roundtrip",
    "gpu": "builtins::math::reduction::std::tests::std_wgpu_dim1_sample_matches_cpu"
  },
  "description": "`std(x)` measures the spread of the elements in `x`. By default RunMat matches MATLAB\u2019s sample definition (dividing by `n-1`) and works along the first non-singleton dimension.",
  "behaviors": [
    "`std(X)` on an `m \u00d7 n` matrix returns a `1 \u00d7 n` row vector with the sample standard deviation of each column.",
    "`std(X, 1)` switches to population normalisation (`n` in the denominator). Use `std(X, 0)` or `std(X, [])` to keep the default sample behaviour.",
    "`std(X, flag, dim)` lets you pick both the normalisation (`flag = 0` sample, `1` population, or `[]`) and the dimension to reduce. `std(X, flag, 'all')` collapses every dimension, while `std(X, flag, vecdim)` accepts a dimension vector such as `[1 3]` and reduces all listed axes in a single call. Multi-axis reductions execute on the host today when the active GPU provider cannot fuse them.",
    "Strings like `'omitnan'` and `'includenan'` decide whether `NaN` values are skipped or propagated.",
    "Optional out-type arguments (`'double'`, `'default'`, `'native'`, or `'like', prototype`) mirror MATLAB behaviour. `'native'` rounds scalar integer results back to their original class; `'like'` mirrors both the numeric class and device residency of `prototype` (complex prototypes yield complex outputs with zero imaginary parts).",
    "Logical inputs are promoted to double precision before reduction so that results follow MATLAB\u2019s numeric rules.",
    "Empty slices return `NaN` with MATLAB-compatible shapes. Scalars return `0`, regardless of the normalisation mode.",
    "Dimensions greater than `ndims(X)` leave the input untouched.",
    "Weighted standard deviations (`flag` as a vector) are not implemented yet; RunMat reports a descriptive error when they are requested.\n\nComplex tensors are not currently supported; convert them to real magnitudes manually before calling `std`."
  ],
  "examples": [
    {
      "description": "Sample standard deviation of a vector",
      "input": "x = [1 2 3 4 5];\ns = std(x);                 % uses flag = 0 (sample) by default",
      "output": "s = 1.5811;"
    },
    {
      "description": "Population standard deviation of each column",
      "input": "A = [1 3 5; 2 4 6];\nspop = std(A, 1);           % divide by n instead of n-1",
      "output": "spop = [0.5 0.5 0.5];"
    },
    {
      "description": "Collapsing every dimension at once",
      "input": "B = reshape(1:12, [3 4]);\noverall = std(B, 0, 'all');",
      "output": "overall = 3.6056;"
    },
    {
      "description": "Reducing across multiple dimensions",
      "input": "C = cat(3, [1 2; 3 4], [5 6; 7 8]);\nsliceStd = std(C, [], [1 3]);   % keep columns, reduce rows & pages",
      "output": "sliceStd = [2.5820 2.5820];"
    },
    {
      "description": "Ignoring NaN values",
      "input": "D = [1 NaN 3; 2 4 NaN];\nrowStd = std(D, 0, 2, 'omitnan');",
      "output": "rowStd = [1.4142; 1.4142];"
    },
    {
      "description": "Matching a prototype using `'like'`",
      "input": "proto = gpuArray(single(42));\nG = gpuArray(rand(1024, 512));\nspread = std(G, 1, 'all', 'like', proto);\nanswer = gather(spread);"
    },
    {
      "description": "Preserving default behaviour with an empty normalisation flag",
      "input": "C = [1 2; 3 4];\nrowStd = std(C, [], 2);",
      "output": "rowStd = [0.7071; 0.7071];"
    }
  ],
  "faqs": [
    {
      "question": "What values can I pass as the normalisation flag?",
      "answer": "Use `0` (or `[]`) for the sample definition, `1` for population. RunMat rejects non-scalar weight vectors and reports that weighted standard deviations are not implemented yet."
    },
    {
      "question": "How can I collapse multiple dimensions?",
      "answer": "Pass a vector of dimensions such as `std(A, [], [1 3])`. You can also use `'all'` to collapse every dimension into a single scalar."
    },
    {
      "question": "How do `'omitnan'` and `'includenan'` work?",
      "answer": "`'omitnan'` skips NaN values; if every element in a slice is NaN the result is NaN. `'includenan'` (the default) propagates a single NaN to the output slice."
    },
    {
      "question": "What do `'native'` and `'like'` do?",
      "answer": "`'native'` rounds scalar results back to the input\u2019s integer class (multi-element outputs stay in double precision for now), while `'double'`/`'default'` keep double precision. `'like', prototype` mirrors both the numeric class and the device residency of `prototype`, including GPU tensors; complex prototypes produce complex outputs with zero imaginary parts."
    },
    {
      "question": "What happens if I request a dimension greater than `ndims(X)`?",
      "answer": "RunMat returns the input unchanged so that MATLAB-compatible code relying on that behaviour continues to work."
    },
    {
      "question": "Are complex inputs supported?",
      "answer": "Not yet. RunMat currently requires real inputs for `std`. Convert complex data to magnitude or separate real/imaginary parts before calling the builtin."
    }
  ],
  "links": [
    {
      "label": "mean",
      "url": "./mean"
    },
    {
      "label": "sum",
      "url": "./sum"
    },
    {
      "label": "median",
      "url": "./median"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    },
    {
      "label": "gather",
      "url": "./gather"
    }
  ],
  "source": {
    "label": "`crates/runmat-runtime/src/builtins/math/reduction/std.rs`",
    "url": "https://github.com/runmat-org/runmat/blob/main/crates/runmat-runtime/src/builtins/math/reduction/std.rs"
  },
  "gpu_residency": "Usually you do not need to call `gpuArray` manually. The fusion planner keeps tensors on the GPU across fused expressions and gathers them only when necessary. For explicit control or MATLAB compatibility, you can still call `gpuArray`/`gather` yourself.",
  "gpu_behavior": [
    "When RunMat Accelerate is active, device-resident tensors remain on the GPU whenever the provider implements the relevant hooks. Providers that expose `reduce_std_dim`/`reduce_std` execute the reduction in-place on the device; the default WGPU backend currently supports two-dimensional inputs, single-axis reductions, and `'includenan'` only. Whenever `'omitnan'`, multi-axis reductions, or unsupported shapes are requested, RunMat transparently gathers the data to the host, computes the result there, and then applies the requested output template (`'native'`, `'like'`) before returning."
  ]
}
