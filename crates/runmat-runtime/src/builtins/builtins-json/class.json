{
  "title": "class",
  "category": "introspection",
  "keywords": [
    "class",
    "type inspection",
    "gpuArray class",
    "MATLAB class name",
    "isa"
  ],
  "summary": "Return the MATLAB class name for scalars, arrays, handles, and objects.",
  "references": [
    "https://www.mathworks.com/help/matlab/ref/class.html",
    "https://www.mathworks.com/help/matlab/ref/isa.html"
  ],
  "gpu_support": {
    "elementwise": false,
    "reduction": false,
    "precisions": [],
    "broadcasting": "none",
    "notes": "No GPU kernels run. RunMat inspects metadata for gpuArray inputs and returns the class string without gathering data."
  },
  "fusion": {
    "elementwise": false,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::introspection::class::tests",
    "integration": null
  },
  "description": "`class(x)` returns the name of the MATLAB class that `x` belongs to. The result is a string scalar that you can use for diagnostics, branching, or display logic.",
  "behaviors": [
    "Real or complex double-precision inputs (including empty numeric arrays) report `\"double\"`. Integer scalars or tensors report their narrow class such as `\"int16\"` or `\"uint8\"`.",
    "Logical scalars and arrays report `\"logical\"`. Character arrays return `\"char\"`, while string scalars or arrays return `\"string\"`.",
    "Cell arrays, structs, and user-defined `classdef` objects report `\"cell\"`, `\"struct\"`, or the class name that defined the object.",
    "Function handles and anonymous closures both report `\"function_handle\"`. Listeners return `\"event.listener\"`.",
    "`gpuArray` values report `\"gpuArray\"` without gathering data. Use `classUnderlying` if you need the element type of the device array.",
    "Handle objects, including deleted handles, return the class name that introduced the handle. Metadata-only values such as `classref(\"Point\")` report `\"meta.class\"`."
  ],
  "examples": [
    {
      "description": "Check the class of a numeric scalar",
      "input": "c = class(42)",
      "output": "c = \"double\""
    },
    {
      "description": "Inspect the class of a string array",
      "input": "names = [\"Ada\", \"Grace\", \"Edsger\"];\nclass_name = class(names)",
      "output": "class_name = \"string\""
    },
    {
      "description": "Determine whether a cell array stays typed as a cell",
      "input": "cells = {1, \"two\", 3};\ncell_class = class(cells)",
      "output": "cell_class = \"cell\""
    },
    {
      "description": "Detect the class of gpuArray data without gathering",
      "input": "G = gpuArray(rand(4));\ng_class = class(G)",
      "output": "g_class = \"gpuArray\""
    },
    {
      "description": "Report the class name of a custom object",
      "input": "P = classref(\"Point\").origin();\npoint_class = class(P)",
      "output": "point_class = \"Point\""
    }
  ],
  "faqs": [
    {
      "question": "Does `class` return a string or a character array?",
      "answer": "`class` returns a string scalar, matching modern MATLAB behaviour. Convert the result with `char(class(...))` if you need a legacy character row vector."
    },
    {
      "question": "How do I check whether a value is numeric?",
      "answer": "Use `isa(x, \"numeric\")` to handle floats, complex numbers, and integers. `class` reports the concrete class (`\"double\"`, `\"int32\"`, and so on)."
    },
    {
      "question": "Will `class` gather gpuArray inputs?",
      "answer": "No. RunMat inspects metadata and returns `\"gpuArray\"` immediately; buffers stay on the device."
    },
    {
      "question": "What does `class` return for handle objects?",
      "answer": "`class` returns the object’s defining class name (for example `\"MyHandleClass\"`). Use `isa(h, \"handle\")` to test for handle semantics."
    },
    {
      "question": "What happens if I pass a struct or cell array?",
      "answer": "Structs return `\"struct\"` and cell arrays return `\"cell\"`, matching MATLAB."
    },
    {
      "question": "What is the class of function handles?",
      "answer": "Both named function handles and anonymous closures report `\"function_handle\"`."
    },
    {
      "question": "Can I distinguish string and char arrays?",
      "answer": "Yes. `class(\"hello\")` yields `\"string\"` while `class('hello')` yields `\"char\"`."
    },
    {
      "question": "What about metadata objects such as `classref`?",
      "answer": "Calling `class(classref(\"Point\"))` returns `\"meta.class\"`. Use the returned meta-class object to inspect properties or superclasses."
    }
  ],
  "links": [
    {
      "label": "isa",
      "url": "./isa"
    },
    {
      "label": "isnumeric",
      "url": "./isnumeric"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    },
    {
      "label": "gather",
      "url": "./gather"
    }
  ],
  "source": {
    "label": "class",
    "url": "class"
  },
  "gpu_residency": "You do not need to call `gpuArray` purely to query a value’s class. The auto-offload planner keeps tensors on the GPU whenever profitable, and `class` simply returns the residency-aware class name without altering where the data lives. Explicit `gpuArray` and `gather` calls remain available for compatibility with MATLAB code that manages residency manually.",
  "gpu_behavior": [
    "`class` is an introspection-only builtin. When the input resides on the GPU, RunMat reads the residency metadata, returns the class name immediately, and leaves the data in place. No kernels are launched and no buffers are copied back to the CPU, so providers do not need to expose any hooks."
  ]
}
