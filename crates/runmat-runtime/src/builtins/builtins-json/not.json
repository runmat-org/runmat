{
  "title": "not",
  "category": "logical/bit",
  "keywords": [
    "logical not",
    "boolean negation",
    "gpuArray not",
    "MATLAB not",
    "logical invert"
  ],
  "summary": "Element-wise logical negation for scalars, arrays, and gpuArray values.",
  "references": [],
  "gpu_support": {
    "elementwise": true,
    "reduction": false,
    "precisions": [
      "f32",
      "f64"
    ],
    "broadcasting": "matlab",
    "notes": "Executes on the GPU when the provider implements `logical_not`; otherwise inputs gather to the host transparently."
  },
  "fusion": {
    "elementwise": true,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::logical::bit::not::tests",
    "integration": "builtins::logical::bit::not::tests::not_gpu_roundtrip",
    "gpu": "builtins::logical::bit::not::tests::not_wgpu_matches_host_path"
  },
  "description": "`not(X)` inverts the logical interpretation of every element in `X`. Values that evaluate to `true` become `false`, and vice versa. MATLAB treats any non-zero (or non-empty) numeric or complex value as `true`, including `NaN`.",
  "behaviors": [
    "Works on scalars, vectors, matrices, and N-D tensors with MATLAB broadcasting semantics.",
    "Accepts logical, numeric, complex, and character arrays. Character code points equal to zero become `true`, all others become `false`.",
    "Returns a logical scalar when the input has exactly one element; otherwise the result is a logical array matching the input shape.",
    "Honors gpuArray residency. If the active acceleration provider exposes `logical_not`, the entire operation runs on the GPU; otherwise RunMat falls back to the CPU path automatically.",
    "`NaN` evaluates to `true`, so `not(NaN)` produces `false`, consistent with MATLAB."
  ],
  "examples": [
    {
      "description": "Checking if a scalar value is zero",
      "input": "result = not(5)",
      "output": "result =\n     0"
    },
    {
      "description": "Negating a logical mask to find the complement",
      "input": "mask = [true false true];\ninverseMask = not(mask)",
      "output": "inverseMask =\n  1\u00d73 logical array\n     0     1     0"
    },
    {
      "description": "Turning nonzero numeric entries into false values",
      "input": "A = [0 1 2 0];\nB = not(A)",
      "output": "B =\n  1\u00d74 logical array\n     1     0     0     1"
    },
    {
      "description": "Flipping zero and nonzero character codes",
      "input": "chars = ['A' 0 'C'];\nflags = not(chars)",
      "output": "flags =\n  1\u00d73 logical array\n     0     1     0"
    },
    {
      "description": "Performing logical NOT directly on the GPU",
      "input": "G = gpuArray([0 4 0 9]);\ndeviceResult = not(G);\nhostResult = gather(deviceResult)",
      "output": "deviceResult =\n  1\u00d74 gpuArray logical array\n     1     0     1     0\nhostResult =\n  1\u00d74 logical array\n     1     0     1     0"
    }
  ],
  "faqs": [
    {
      "question": "Does `not` return logical values?",
      "answer": "Yes. Scalar inputs yield logical scalars (`true`/`false`). Array inputs produce logical arrays where each element is either `0` or `1`."
    },
    {
      "question": "How does `not` treat `NaN` or complex numbers?",
      "answer": "`NaN` and complex numbers with any non-zero component evaluate as `true`, so `not(NaN)` and `not(1+2i)` return `false`."
    },
    {
      "question": "Can I pass a `gpuArray` to `not`?",
      "answer": "Absolutely. If the provider implements `logical_not`, the negation runs entirely on the GPU. Otherwise the runtime gathers to the host, performs the operation, and returns a logical array."
    },
    {
      "question": "What happens with empty arrays?",
      "answer": "Empty inputs produce empty logical outputs with matching shape, preserving MATLAB's empty propagation semantics."
    },
    {
      "question": "Is there a difference between `not(X)` and `~X`?",
      "answer": "No. They share the same element-wise semantics. The functional form is convenient for higher-order APIs or when passing the operator as a handle."
    },
    {
      "question": "Does `not` modify the input in place?",
      "answer": "No. It returns a new logical value. When operating on gpuArrays, the provider writes into a fresh buffer so the original data remains unchanged."
    }
  ],
  "links": [
    {
      "label": "and",
      "url": "./and"
    },
    {
      "label": "or",
      "url": "./or"
    },
    {
      "label": "xor",
      "url": "./xor"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    },
    {
      "label": "gather",
      "url": "./gather"
    }
  ],
  "source": {
    "label": "",
    "url": ""
  },
  "gpu_residency": "You usually do **not** have to call `gpuArray` manually. RunMat's auto-offload planner moves data to the GPU when a fused expression benefits from device execution. The `not` builtin preserves existing residency; results remain on the GPU until you gather them or another operation requires host access. Use `gpuArray` when porting MATLAB code that already does so explicitly or when you want to pin tensors to the GPU ahead of time.",
  "gpu_behavior": [
    "When RunMat Accelerate is active, `not` dispatches to the provider hook `logical_not`. Providers write `0` or `1` into a device buffer, keeping the result resident on the GPU. If the provider does not implement the hook, RunMat gathers the input to host memory, executes the CPU implementation, and (if the caller passed a `gpuArray`) returns a logical array on the host so the call never fails."
  ]
}
