{
  "title": "symrcm",
  "category": "math/linalg/structure",
  "keywords": [
    "symrcm",
    "reverse cuthill-mckee",
    "bandwidth reduction",
    "symmetric ordering",
    "permutation",
    "gpu"
  ],
  "summary": "Compute the symmetric reverse Cuthill-McKee permutation that reduces matrix bandwidth.",
  "references": [
    "Alan George and Joseph W. Liu, 'Computer Solution of Large Sparse Positive Definite Systems', Prentice Hall, 1981."
  ],
  "gpu_support": {
    "elementwise": false,
    "reduction": false,
    "precisions": [
      "f32",
      "f64"
    ],
    "broadcasting": "none",
    "notes": "Acceleration providers may implement the `sym_rcm` hook. The WGPU backend currently downloads the matrix, runs the host algorithm, and returns the permutation."
  },
  "fusion": {
    "elementwise": false,
    "reduction": false,
    "max_inputs": 1,
    "constants": "inline"
  },
  "requires_feature": null,
  "tested": {
    "unit": "builtins::math::linalg::structure::symrcm::tests",
    "integration": "builtins::math::linalg::structure::symrcm::tests::symrcm_gpu_roundtrip"
  },
  "description": "`r = symrcm(A)` returns a permutation vector that reorders a symmetric (or structurally symmetric) matrix to reduce its bandwidth. You can use the permutation as `A(r, r)` to obtain a matrix with a tighter band structure, which improves factorisation and linear solve performance for sparse matrices.",
  "behaviors": [
    "Treats the input as an undirected graph based on the pattern of `A + A'`. Any value that is not exactly zero (including `NaN` or `Inf`) creates an edge; diagonal entries are ignored because they do not affect bandwidth.",
    "Accepts numeric, logical, and complex matrices. Logical and integer inputs are promoted to double precision internally, and complex entries are considered nonzero when either the real or imaginary component is nonzero.",
    "Requires a square matrix (scalars and the empty matrix are allowed). Inputs with more than two non-singleton dimensions raise an error, matching MATLAB matrix semantics.",
    "Processes disconnected components independently. Each component starts from a minimum degree vertex, runs a Cuthill-McKee breadth-first search, and the component ordering is reversed to produce the symmetric variant.",
    "Returns a row vector of 1-based indices. Fully diagonal or zero matrices produce the identity permutation."
  ],
  "examples": [
    {
      "description": "Reducing bandwidth of a near-band matrix",
      "input": "A = [4 1 0 0 2;\n     1 4 1 0 0;\n     0 1 4 1 0;\n     0 0 1 4 1;\n     2 0 0 1 4];\nr = symrcm(A);\nB = A(r, r);\nbandwidth(A)\nbandwidth(B)"
    },
    {
      "description": "Handling disconnected components with `symrcm`",
      "input": "A = [1 1 0 0 0;\n     1 1 0 0 0;\n     0 0 1 0 1;\n     0 0 0 1 1;\n     0 0 1 1 1];\nr = symrcm(A);\nB = A(r, r)"
    },
    {
      "description": "Using `symrcm` with logical adjacency matrices",
      "input": "adj = logical([0 1 0 0;\n               1 0 1 0;\n               0 1 0 1;\n               0 0 1 0]);\nr = symrcm(adj)"
    },
    {
      "description": "Applying `symrcm` to GPU matrices",
      "input": "G = gpuArray([0 1 0 0 2;\n              1 0 1 0 0;\n              0 1 0 1 0;\n              0 0 1 0 1;\n              2 0 0 1 0]);\nr = symrcm(G);\nH = gather(G(r, r))"
    }
  ],
  "faqs": [
    {
      "question": "What class of matrices benefit from `symrcm`?",
      "answer": "Any symmetric (or structurally symmetric) sparse matrix whose bandwidth dominates solver cost, such as discretised PDE operators, circuit matrices, or graph Laplacians."
    },
    {
      "question": "Does `symrcm` modify the matrix?",
      "answer": "No. It returns a permutation vector. Apply it as `A(r, r)` or reorder vectors with `x(r)`."
    },
    {
      "question": "What happens if the matrix is not symmetric?",
      "answer": "RunMat mirrors MATLAB and forms the pattern of `A + A'` internally. As long as the matrix has symmetric nonzero structure, `symrcm` works. Strongly asymmetric inputs may lead to less effective orderings but still produce a valid permutation."
    },
    {
      "question": "Are diagonal entries considered?",
      "answer": "Diagonal entries are ignored when building the graph. Only off-diagonal nonzeros contribute edges, which aligns with MATLAB semantics."
    },
    {
      "question": "How are NaNs or Infs handled?",
      "answer": "Any value that is not numerically equal to zero is treated as nonzero, including `NaN` or `Inf`. This matches MATLAB's structural interpretation."
    },
    {
      "question": "Can I use `symrcm` on dense matrices?",
      "answer": "Yes. Dense inputs are supported. For dense matrices, the result is typically the identity permutation because all vertices have high degree."
    },
    {
      "question": "How do I verify the permutation improves bandwidth?",
      "answer": "Compute `bandwidth(A)` and `bandwidth(A(r, r))` and compare the results. Lower lower/upper bandwidth values indicate a tighter band and more efficient factorizations."
    },
    {
      "question": "What output shape should I expect?",
      "answer": "The permutation is returned as a row vector (`1 \u00d7 n`). The empty matrix returns the empty row vector `[]`."
    }
  ],
  "links": [
    {
      "label": "rcm",
      "url": "https://www.mathworks.com/help/matlab/ref/rcm.html"
    },
    {
      "label": "symamd",
      "url": "https://www.mathworks.com/help/matlab/ref/symamd.html"
    },
    {
      "label": "bandwidth",
      "url": "./bandwidth"
    },
    {
      "label": "issymmetric",
      "url": "./issymmetric"
    },
    {
      "label": "gpuArray",
      "url": "./gpuarray"
    }
  ],
  "source": {
    "label": "`crates/runmat-runtime/src/builtins/math/linalg/structure/symrcm.rs`",
    "url": "https://github.com/runmat-org/runmat/blob/main/crates/runmat-runtime/src/builtins/math/linalg/structure/symrcm.rs"
  },
  "gpu_residency": "No. The runtime gathers GPU matrices automatically when computing the permutation today. When native GPU implementations land, the same builtin will run entirely on the device without code changes. You can still call `gpuArray` explicitly to mirror MATLAB workflows, but it is optional in RunMat.",
  "gpu_behavior": [
    "RunMat first asks the active acceleration provider whether it implements the `sym_rcm` hook. The WGPU backend exposes this hook today and downloads the matrix once to reuse the optimised CPU algorithm before returning the permutation. Providers without support (or those that report an error) trigger an automatic gather and reuse the host implementation, so results stay correct regardless of GPU capabilities."
  ]
}
