//! Builtin file generator for RunMat runtime.
//!
//! Responsible for creating a skeleton builtin source file under
//! `crates/runmat-runtime/src/builtins/<category>/<name>.rs` and wiring
//! the `mod.rs` chain so the file is compiled. The generated file contains
//! a `#[runtime_builtin]` function stub and a minimal smoke test so filtered
//! cargo test runs succeed immediately.

use std::fs::{self, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};

/// Outcome of a generation attempt.
#[derive(Debug, Clone)]
pub struct GenerateOutcome {
    pub target_file: PathBuf,
    pub created: bool,
    pub updated_mods: Vec<PathBuf>,
}

/// Generate a builtin skeleton if it does not already exist.
/// Returns the target file path and whether it was created.
pub fn generate_if_missing(name: &str, category: &str) -> Result<GenerateOutcome> {
    let workspace_root = std::env::current_dir().context("resolve workspace root")?;
    let builtins_root = workspace_root.join("crates/runmat-runtime/src/builtins");

    let normalized_name = normalize_segment(name);
    let category_segments: Vec<String> = category
        .split('/')
        .filter(|s| !s.trim().is_empty())
        .map(normalize_segment)
        .collect();

    // Ensure module chain exists and is wired via mod.rs files
    let mut updated_mods =
        ensure_module_chain(&builtins_root, &category_segments).context("ensuring module chain")?;

    // Final target file
    let mut leaf_dir = builtins_root.clone();
    for seg in &category_segments {
        leaf_dir.push(seg);
    }
    fs::create_dir_all(&leaf_dir).with_context(|| format!("creating {}", leaf_dir.display()))?;

    let target_file = leaf_dir.join(format!("{}.rs", normalized_name));
    if target_file.exists() {
        return Ok(GenerateOutcome {
            target_file,
            created: false,
            updated_mods,
        });
    }

    let content = render_builtin_file(name, category, &normalized_name);
    write_new_file(&target_file, &content)?;

    // Ensure the leaf mod.rs declares `mod <name>;`
    let leaf_mod = leaf_dir.join("mod.rs");
    updated_mods.push(leaf_mod.clone());
    append_mod_decl_if_missing(&leaf_mod, &format!("mod {};", normalized_name))?;

    Ok(GenerateOutcome {
        target_file,
        created: true,
        updated_mods,
    })
}

fn ensure_module_chain(builtins_root: &Path, segments: &[String]) -> Result<Vec<PathBuf>> {
    let mut updated = Vec::new();

    // Ensure builtins/mod.rs exists and exposes first segment
    let builtins_mod = builtins_root.join("mod.rs");
    if !builtins_mod.exists() {
        write_new_file(&builtins_mod, "//! Builtins module\n")?;
    }

    if let Some(first) = segments.first() {
        append_mod_decl_if_missing(&builtins_mod, &format!("pub mod {};", first))?;
        updated.push(builtins_mod.clone());
    }

    // Walk segments, ensuring each directory and mod.rs exists and is re-exported from its parent
    let mut current_dir = builtins_root.to_path_buf();
    for i in 0..segments.len() {
        let seg = &segments[i];
        let parent_mod = if i == 0 {
            builtins_root.join("mod.rs")
        } else {
            let mut parent_dir = builtins_root.to_path_buf();
            for s in &segments[0..i] {
                parent_dir.push(s);
            }
            let pm = parent_dir.join("mod.rs");
            if !pm.exists() {
                write_new_file(&pm, "// Auto-generated by runmatfunc\n")?;
            }
            pm
        };

        current_dir.push(seg);
        fs::create_dir_all(&current_dir)
            .with_context(|| format!("creating {}", current_dir.display()))?;

        // Ensure parent mod re-exports this segment
        append_mod_decl_if_missing(&parent_mod, &format!("pub mod {};", seg))?;
        updated.push(parent_mod);

        // Ensure this segment's mod.rs exists
        let current_mod = current_dir.join("mod.rs");
        if !current_mod.exists() {
            write_new_file(&current_mod, "// Auto-generated by runmatfunc\n")?;
            updated.push(current_mod);
        }
    }

    Ok(updated)
}

fn write_new_file(path: &Path, contents: &str) -> Result<()> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).with_context(|| format!("creating {}", parent.display()))?;
    }
    let mut file = OpenOptions::new()
        .write(true)
        .create_new(true)
        .open(path)
        .with_context(|| format!("creating {}", path.display()))?;
    file.write_all(contents.as_bytes())
        .with_context(|| format!("writing {}", path.display()))?;
    Ok(())
}

fn append_mod_decl_if_missing(mod_rs: &Path, decl: &str) -> Result<()> {
    let existing = fs::read_to_string(mod_rs).unwrap_or_else(|_| String::new());
    if existing.lines().any(|line| line.trim() == decl) {
        return Ok(());
    }
    let mut file = OpenOptions::new()
        .append(true)
        .create(true)
        .open(mod_rs)
        .with_context(|| format!("opening {}", mod_rs.display()))?;
    if !existing.ends_with('\n') {
        file.write_all(b"\n").ok();
    }
    file.write_all(decl.as_bytes())
        .and_then(|_| file.write_all(b"\n"))
        .with_context(|| format!("appending to {}", mod_rs.display()))?;
    Ok(())
}

fn normalize_segment(segment: &str) -> String {
    segment.trim().to_ascii_lowercase().replace([' ', '-'], "_")
}

fn render_builtin_file(name: &str, category: &str, _fn_stub: &str) -> String {
    let mut out = String::new();
    out.push_str("//! Generated by runmatfunc\n");
    out.push_str("//!\n");
    out.push_str("//! This file is a scaffold only. Use Codex (run with --codex) to author\n");
    out.push_str("//! the full builtin following crates/runmat-runtime/BUILTIN_PACKAGING.md.\n\n");
    out.push_str(&format!("// name: {}\n// category: {}\n", name, category));
    out
}
